# 4. 트랜잭션 불변성 vs 상태 변경 전략

날짜: 2025-12-04

## 상태

채택됨 (Accepted)

## 배경 (Context)

원장(Ledger) 도메인의 `Transaction` 엔티티는 데이터 무결성을 보장하기 위해 불변(Immutable)으로 설계되었습니다. 그러나 비즈니스 요구사항에 따라 트랜잭션은 '역분개(Reversed)'되어 취소될 수 있어야 하며, 이는 `POSTED`에서 `REVERSED`로의 상태 변경을 의미합니다.

다음 두 가지 원칙 사이에서 충돌을 경험했습니다:
1.  **불변성 (Immutability)**: 도메인 객체는 생성 후 변경되지 않아야 부작용(Side Effect)과 경쟁 상태(Race Condition)를 방지할 수 있다.
2.  **비즈니스 로직 (Business Logic)**: 트랜잭션의 상태는 생명주기에 따라 명확하게 업데이트되어야 한다.

다음 세 가지 방안을 고려했습니다:

1.  **순수 불변성 유지 (상태 변경 없음)**:
    *   `Transaction`을 불변으로 유지한다.
    *   원본 트랜잭션의 상태를 업데이트하지 않는다.
    *   취소 여부는 역분개 트랜잭션의 존재 여부(`reversalOfTransactionId`)를 조회하여 판단한다.
    *   **장점**: 완벽한 불변성 유지.
    *   **단점**: 취소 여부 확인을 위해 매번 DB 조회(`SELECT count(*) ...`)가 필요하여 성능 저하 우려. 조회 누락 시 "중복 취소" 버그 발생 위험 높음.

2.  **가변 상태 허용 (Setter 메서드)**:
    *   `status` 필드의 `final`을 제거한다.
    *   `setStatus(TransactionStatus)` 메서드를 추가한다.
    *   **장점**: 구현이 단순함.
    *   **단점**: 불변성 원칙 위배. 객체가 어디서든 수정될 수 있어 예측 불가능한 동작과 동시성 문제 발생 가능성 있음.

3.  **Copy-on-Write (권장)**:
    *   `Transaction`을 불변으로 유지한다 (모든 필드 `final`).
    *   `toReversed()` 메서드를 추가하여, 상태가 변경된 **새로운** `Transaction` 객체를 반환한다.
    *   **장점**: 불변성 유지. 코드에 의도가 명확히 드러남. 상태 확인 성능이 O(1)로 효율적임. 중복 취소를 객체 수준에서 방지 가능.
    *   **단점**: 새로운 객체를 생성해야 함 (현대 JVM에서는 비용이 무시할 수준임).

## 결정 (Decision)

**방안 3: Copy-on-Write**를 선택합니다.

`Transaction` 클래스에 `toReversed()` 메서드를 구현할 것입니다. 이 메서드는 다음과 같이 동작합니다:
1.  현재 트랜잭션이 역분개 가능한 상태(`POSTED`)인지 검증합니다.
2.  ID와 데이터는 동일하지만, `status`가 `REVERSED`로 설정된 **새로운** `Transaction` 객체를 반환합니다.

**의미론적 명세**:
이 메서드는 단순한 상태 변경이 아니라, **"이 거래에 대응하는 역분개가 존재함을 표시하는 상태로 전환한다"**는 논리적 취소 상태로의 전이를 의미합니다. `toReversed`라는 네이밍은 불변 객체의 변환(Transformation)을 의미하는 Java 표준 관례(`toString`, `toList` 등)를 따르며, 원본 객체는 변하지 않고 새로운 상태의 객체가 반환됨을 명확히 합니다.

이 방식은 다음과 같은 효과를 제공합니다:
*   불변 객체의 안전성을 유지합니다.
*   상태 전이 로직을 도메인 엔티티 내부에 캡슐화합니다.
*   비싼 DB 조회 없이 효율적으로 트랜잭션 상태를 확인할 수 있습니다.
*   객체 상태를 먼저 확인하여 "중복 역분개"를 원천적으로 방지합니다.

## 결과 (Consequences)

*   **긍정적 효과**:
    *   `Transaction` 객체의 스레드 안전성(Thread-safety)이 보장됩니다.
    *   상태 변경 의도가 코드에 명확히 드러납니다.
    *   "이미 취소된 트랜잭션"을 O(1)로 감지할 수 있어 시스템 안정성이 향상됩니다.
*   **부정적 효과**:
    *   개발자는 원본 객체가 아닌 반환된 새 객체를 사용해야 함을 인지해야 합니다 (함수형 프로그래밍의 표준 패턴이므로 수용 가능).
