# 🎯 Kuku Securities 프로젝트 목표 (v4 - 조정안)

> **목표:** 3개월(12주) 동안 자바 스프링 기반의 모의 증권 트레이딩 시스템을 구현하여,  
> **증권 서버 개발자로 합격할 수 있을 만큼의 도메인 이해와 문제 해결 능력을 증명한다.**

---

## ⚡ Depth Strategy: 범위를 줄인 만큼 깊이로 압도한다

> **철학**: 기능이 단순해진 만큼 **"왜 이렇게 했는가"**와 **"수치로 증명"**으로 한다.

### 1. 시장가 주문의 함정: 슬리피지(Slippage) 방어

> "시장가 = 단순한 price × quantity 계산" 이라고 생각하게 만들지 않는다.

| 시나리오 | 문제 | 해결 전략 |
|:---------|:-----|:---------|
| 주문 시점과 체결 시점의 가격 괴리 | 시장가 주문 시 예상 가격보다 훨씬 비싸게/싸게 체결 | **슬리피지 허용 범위 설정** (±X%) |
| 급등/급락장에서의 주문 | 사용자 의도와 다른 체결 | 허용 범위 이탈 시 **REJECTED** 처리 |
| 호가 부족 상황 | 물량 부족으로 부분 체결만 가능 | **부분 체결 + 잔량 취소** 정책 |

**산출물**:
- [ ] **[ADR]** 슬리피지 방어 전략 (`/docs/adr/010-slippage-protection.md`)
  - 허용 범위 결정 근거 (증권사 실제 사례 리서치)
  - 부분 체결 시 원장 처리 방법
  - 거래소별 정책 차이 고려

---

### 2. 극한의 동시성 테스트: 수치로 증명한다

> 단순히 CyclicBarrier로 스레드 몇 개 돌리는 것이 아니다.

**시나리오**: 재고(예수금)가 **100만원** 남았을 때, **1000명이 동시에 100만원 시장가 매수**

| 측정 항목 | 목표 | 검증 방법 |
|:---------|:-----|:---------|
| **정합성** | 단 1건만 성공, 999건 실패 | 잔액 음수 방지 검증 |
| **TPS** | 목표치 설정 및 측정 | k6 부하 테스트 |
| **Latency P99** | 목표치 설정 및 측정 | k6 부하 테스트 |
| **Deadlock 발생 여부** | 0건 | MySQL 로그 분석 |
| **DB CPU 사용률** | 피크 측정 | Grafana 모니터링 |

**장애 주입 테스트**:
- [ ] **Redis 장애 시**: Redis 죽었을 때 DB Lock만으로 방어 가능한가?
- [ ] **DB Connection Pool 고갈**: HikariCP exhaustion 상황에서 graceful 실패?
- [ ] **Optimistic Lock 폭풍**: 동시 충돌 1000건 발생 시 Retry 폭주 방지?

**산출물**:
- [ ] **[Experiment]** 동시성 실험 리포트 (`/docs/experiments/concurrency-stress-test.md`)
  - 시나리오별 TPS/Latency/에러율 그래프
  - Lock 전략별 성능 비교 표
  - 병목 지점 분석 및 개선 과정

---

### 3. Graceful Degradation: 장애 대응

> 장애가 나도 사용자가 당황하지 않게. 백엔드에서의 Graceful Degradation.

| 장애 상황 | 기존 방식 | Graceful Degradation |
|:---------|:---------|:--------------------|
| 시세 서버 다운 | 주문 불가 (500 Error) | **마지막 캐시된 시세로 주문 접수** → 체결 보류 |
| Kafka 다운 | 트랜잭션 롤백 | **Outbox에 저장** → 복구 후 발행 |
| 외부 API 타임아웃 | 무한 대기 또는 실패 | **Circuit Breaker + Fallback** |
| DB 과부하 | 전체 장애 | **Rate Limiting + 우선순위 큐** |

**구현 전략**:
- [ ] **PENDING 주문 큐**: 시세 서버 장애 시 주문을 PENDING으로 접수 후 복구 시 처리
- [ ] **Fallback Price**: 시세 조회 실패 시 마지막 유효 시세 + 경고 플래그
- [ ] **Circuit Breaker**: Resilience4j로 외부 의존성 보호
- [ ] **사용자 피드백**: "현재 시세 조회 지연 중, 주문은 정상 접수되었습니다" 메시지 설계

**산출물**:
- [ ] **[ADR]** Graceful Degradation 전략 (`/docs/adr/011-graceful-degradation.md`)
- [ ] **[Diagram]** 장애 시나리오별 시스템 동작 흐름도

---

## 📋 v3 대비 주요 변경점

| 항목 | v3 (기존) | v4 (조정안) | 변경 이유 |
|:-----|:---------|:-----------|:---------|
| Week 4 Kafka | Outbox + Kafka 연동 완료 | Outbox 설계만, Kafka는 Week 7로 | E2E 플로우와 함께 연동이 의미 있음 |
| Week 6 | 동시성 Lock 비교 | + **극한 동시성 테스트** | 수치로 증명하는 스토리 |
| Week 7 범위 | 즉시체결 + 수수료 + PENDING 모드 | 시장가 + **슬리피지 방어** + Kafka | 도메인 깊이 추가 |
| Week 8 | 멱등성만 | 멱등성 + 수수료 계산 | Week 7에서 이관 |
| Week 10 | 한투 API 필수 연동 | Mock 기반, 한투 API 선택적 | 외부 의존성 리스크 완화 |
| Week 11 | WebSocket 필수 | **버퍼 주차** (선택적 WebSocket) | 일정 리스크 대응 |
| Week 12 | 부하 테스트 + 정리 | + **Graceful Degradation** | 장애 대응 스토리 |
| 지정가/Order Book | Week 7 v2로 포함 | **Out of Scope** | 3개월 내 현실적 범위 조정 |

---

## 1. 이 프로젝트가 증명해야 하는 것

1. **도메인 이해**
   - 주문 → 체결 → 원장 → 포지션/포트폴리오로 이어지는 **트레이딩 플로우**를 이해하고 구현할 수 있는가?
   - **정합성, 실시간성, 규제/업무 제약**을 어느 정도 고려하고 있는가?
   - ⭐ **슬리피지, 부분 체결** 같은 실제 트레이딩 이슈를 인지하고 있는가?

2. **엔지니어링 역량**
   - Java / Spring / MySQL / Redis / Kafka 등 **실제 증권사와 유사한 스택**을 깊이 있게 활용했는가?
   - **MSA + 이벤트 기반 아키텍처**를 이해하고, 적절한 수준에서 설계·구현할 수 있는가?
   - 성능/동시성/장애 상황에 대해 **실험하고 개선한 흔적**이 있는가?
   - ⭐ **수치(TPS, Latency, 에러율)**로 성능을 증명할 수 있는가?

3. **문제 해결 스토리**
   - "무슨 문제가 있었고, 어떻게 가설을 세우고, 어떤 실험을 했고, 어떤 결론에 도달했는지"를 **논리적으로 설명**할 수 있는가?
   - README, ADR, 로그, 테스트 코드 등으로 **사고 과정이 남아 있는가?**
   - ⭐ **장애 상황에서 시스템이 어떻게 동작하는지** 설명할 수 있는가?

4. **협업 가능한 개발자 이미지**
   - 코드 구조, 문서, 커밋/이슈 관리가 **다른 사람이 보기에도 이해하기 쉬운 수준**인가?

---

## 2. 프로젝트 핵심 가치

### 2.1 Why-Driven Engineering
- 모든 주요 결정에 대해 **대안 비교와 Trade-off**를 기록한다.
- `/docs/adr/ADR-XXX-*.md` 형태로 **Architecture Decision Record** 작성.

### 2.2 Resilience (회복 탄력성)
- 장애 상황에서 **데이터가 꼬이지 않고**, **Unknown 상태를 인지**하며, **사후 복구가 가능**해야 한다.
- **실행 계획**: Week 4 (Outbox 설계), Week 7 (Kafka 연동), Week 12 (장애 복구 테스트)

### 2.3 Data Integrity (데이터 무결성)
- 원장(Ledger) 서비스는 **단일 진실 공급원(Single Source of Truth)**로 동작해야 한다.
- **실행 계획**: Week 2 (이중부기), Week 3 (역분개), Week 6 (동시성 테스트)

### 2.4 High Concurrency (고동시성)
- 대규모 트래픽과 주문 폭주 상황에서도 동시성 이슈를 완벽하게 제어한다.
- **실행 계획**: Week 6 (Lock 비교 실험), Week 12 (부하 테스트)

---

## 3. 시스템 아키텍처 (MSA)

| 서비스 | 역할 | 구현 시점 |
|--------|------|:--------:|
| **Core Ledger** | 계좌, 예수금, 주식 잔고 관리. 이중 부기 준수. | Week 2-4 |
| **Order System** | 매수/매도 주문 접수, 주문 상태 관리. | Week 5-6 |
| **Matching Engine** | 외부 시세 기반 모의 체결 (시장가만). | Week 7 |
| **Portfolio** | 계좌별 보유 종목, 평가 손익 계산. | Week 9 |
| **Market Data** | 시세 수신 (Mock 기반, 한투 API 선택적). | Week 10 |
| **API Gateway** | 인증/인가, Rate Limiting. | Week 12 선택 |

---

## 4. 12주 상세 로드맵 (조정안)

### Phase 1: The Foundation & The Ledger (원장 시스템)
> "돈은 거짓말하지 않는다"

---

#### Week 1: 프로젝트 셋업 및 MSA 기반 마련

**구현**
- [x] Multi-module Gradle 구성 (Domain, API, Common).
- [x] Docker Compose & Kubernetes 로컬 환경 구성.
- [x] CI/CD 파이프라인 구축 (Github Actions).
- [x] **[ADR]** Monolithic vs MSA: 초기 단계에서 MSA를 선택한 이유와 비용 분석.

**문서화**
- [x] **[Diagram]** C4 Context Diagram 초안 작성.

---

#### Week 2: 원장(Ledger) 도메인 설계 및 DB 모델링

**구현**
- [x] 이중 부기 데이터 모델 설계 (Account, Transaction, JournalEntry, Balance).
- [x] AccountType, TransactionType, businessRefId 설계.
- [x] MySQL 테이블 설계 및 인덱스 전략.
- [x] **[ADR]** MySQL vs MongoDB: 금융 데이터 처리에 적합한 DB 선택.

**문서화**
- [x] **[Diagram]** Ledger 도메인 ERD 작성.
- [x] **[Diagram]** C4 Container Diagram (Ledger 서비스 중심).

---

#### Week 3: 원장 정합성 구현 (Transaction & Isolation)

**구현**
- [x] 입출금, 자산 이동 트랜잭션 구현.
- [x] TransactionStatus 및 reversal(역분개) 패턴 적용.
- [x] 트랜잭션 격리 수준(Isolation Level)에 따른 동시성 테스트.
- [x] **[Deep Dive]** Spring `@Transactional`의 동작 원리와 주의점.

**문서화**
- [x] **[Diagram]** 입출금 트랜잭션 Sequence Diagram.
- [x] **[Diagram]** 역분개 플로우 다이어그램.

---

#### Week 4: 원장 시스템 검증 테스트 ⚠️ 범위 조정

**구현**
- [x] UNKNOWN 상태 정의 및 구현.
- [x] PENDING → POSTED 2단계 전환 로직 (`ConfirmTransactionService`).
- [x] 동시성 테스트 (동일 계좌 동시 입출금).
- [x] Optimistic Lock 실패 Retry 전략 (@Retryable).
- [x] Outbox 패턴 **설계** (LedgerPostedEvent, LedgerReversedEvent).
  > ⚠️ **Kafka 연동은 Week 7로 이관** - E2E 플로우와 함께 구현

**문서화**
- [x] **[ADR]** Retry 전략 (`007-retry-strategy.md`).
- [x] **[ADR]** Outbox 패턴 (`008-outbox-pattern.md`).
- [ ] **[Diagram]** C4 Component Diagram (Ledger 내부 구조).

**회고**
- [ ] Week 4 회고 작성 (`/docs/retrospectives/week-04.md`)

---

### Phase 2: The Order System & Simulation
> "폭주하는 트래픽을 견디면서, 모의투자하라"

---

#### Week 5: 주문 상태 머신(State Machine) 설계 + API 레이어

**구현**
- [ ] 주문 생명주기 관리: CREATED → VALIDATED → FILLED / REJECTED / CANCELLED.
- [ ] 상태 패턴(State Pattern) 적용 및 코드 유연성 확보.
- [ ] 기본 Validation:
  - 예수금 부족, 보유 수량 부족 시 REJECT
  - 장 운영 시간 위반 시 REJECT
- [ ] **[API] OrderController 구현**:
  - `POST /api/v1/orders` - 주문 생성
  - `GET /api/v1/orders/{orderId}` - 주문 조회
  - `DELETE /api/v1/orders/{orderId}` - 주문 취소
- [ ] **[API] OpenAPI(Swagger) Spec 문서화** (`springdoc-openapi`)

**문서화**
- [ ] **[Diagram]** 주문 상태 머신 다이어그램.
- [ ] **[Diagram]** 주문 API Sequence Diagram.

---

#### Week 6: 동시성 제어 전략 (Concurrency Control) ⭐ 핵심 주차

> **Depth Strategy 적용**: 극한의 동시성 테스트로 수치 증명

**구현**
- [ ] 재고(예수금/주식) 차감 시 Race Condition 해결.
- [ ] **[Experiment]** Optimistic Lock vs Pessimistic Lock vs Redis Distributed Lock 성능 비교.
- [ ] **[극한 테스트]** 재고 100만원, 1000명 동시 100만원 매수 시나리오:
  - 단 1건만 성공, 999건 정확히 실패하는지 검증
  - TPS / Latency P99 측정
  - Deadlock 발생 여부 확인 (MySQL 로그 분석)
  - DB CPU 사용률 피크 측정
- [ ] **[장애 주입 테스트]**:
  - Redis 장애 시 DB Lock만으로 방어 가능한지 검증
  - HikariCP Connection Pool 고갈 상황에서 graceful 실패 확인
  - Optimistic Lock 동시 충돌 1000건 시 Retry 폭주 방지 검증
- [ ] **[Week 4에서 통합]** DB Lock 경쟁 시나리오 테스트 (Deadlock, Lock Timeout).
- [ ] **[ADR]** 상황별 최적의 락킹 전략 선정.

**문서화**
- [ ] **[Experiment]** 동시성 실험 리포트 (`/docs/experiments/concurrency-stress-test.md`)
  - 시나리오별 TPS/Latency/에러율 그래프
  - Lock 전략별 성능 비교 표
  - 병목 지점 분석 및 개선 과정

---

#### Week 7: Matching Engine 구현 + Kafka 연동 ⚠️ 범위 축소

> **Depth Strategy 적용**: 슬리피지 방어로 도메인 깊이 증명

**구현**
- [ ] **시장가(MARKET) 즉시 체결만 구현** (Limit 주문 제외).
  > ⚠️ 지정가 Order Book은 **Out of Scope**으로 제외
- [ ] **[Depth] 슬리피지(Slippage) 방어 로직 구현**:
  - 주문 시점 가격 대비 ±X% 범위 초과 시 REJECTED 처리
  - 부분 체결 + 잔량 취소 정책 구현
  - 슬리피지 허용 범위 설정값 외부화 (application.yml)
- [ ] **Kafka 연동**: Outbox → Kafka Producer → Consumer 연결.
  - LedgerPostedEvent 발행
  - Trade → Ledger 이벤트 플로우 완성
- [ ] Trade → Ledger → Position으로 이어지는 도메인 연동 플로우 정립.
- [ ] **[API] E2E 통합 테스트**:
  - 주문 API 호출 → 체결 → Kafka 이벤트 → 원장 반영 → 잔고 확인
  - Testcontainers (MySQL, Kafka) 활용

**문서화**
- [ ] **[ADR]** 슬리피지 방어 전략 (`/docs/adr/010-slippage-protection.md`)
  - 허용 범위 결정 근거 (증권사 실제 사례 리서치)
  - 부분 체결 시 원장 처리 방법
- [ ] **[Diagram]** 주문 → 체결 → 원장 Event Flow Diagram.
- [ ] **[Diagram]** Ledger 이벤트 흐름도 (Outbox → Kafka → Consumer).
- [ ] **[Diagram]** C4 Container Diagram 업데이트.

---

#### Week 8: 멱등성(Idempotency) 및 수수료 계산 ⚠️ Week 7에서 이관

**구현**
- [ ] 네트워크 타임아웃으로 인한 재시도 시 중복 주문 방지.
- [ ] **[API] Idempotency Key 패턴 구현**:
  - `Idempotency-Key` 헤더 규격 정의
  - 중복 요청 감지 및 409 Conflict 응답
- [ ] **[Week 7에서 이관]** 기본 수수료 계산 구현:
  - 체결 금액 × 0.015% (매수/매도 각각).
  - 수수료를 SYSTEM_FEE 계정에 JournalEntry로 기록.
- [ ] 멱등성과 동시성 제어 전략을 결합한 주문 처리 플로우 정리.

**문서화**
- [ ] **[Diagram]** 멱등성 처리 Sequence Diagram (재시도 시나리오).

---

### Phase 3: Portfolio & Real-time Market Data
> "내 계좌가 얼마나 벌었는지, (가능하다면) 실시간으로 알 수 있다"

---

#### Week 9: 포트폴리오/포지션 서비스 구현

**구현**
- [ ] 계좌별 보유 종목, 수량, 평균 매입가 계산.
- [ ] 평가금액, 평가손익, 수익률 계산 (기초 버전).
- [ ] Trade/원장 데이터로부터 **포지션 재계산** 가능하도록 설계.
- [ ] **[API] PortfolioController 구현**:
  - `GET /api/v1/portfolios/{accountId}` - 포트폴리오 조회
  - `GET /api/v1/portfolios/{accountId}/positions` - 보유 종목 리스트

**문서화**
- [ ] **[Diagram]** Portfolio 도메인 ERD.
- [ ] **[Diagram]** 포지션 재계산 플로우 다이어그램.

---

#### Week 10: Market Data 서비스 ⚠️ 범위 조정

**구현 (필수)**
- [ ] 종목(Symbol), 거래소(Exchange) 도메인 설계.
- [ ] Quote/Candle 공통 도메인 모델 설계.
- [ ] **시세 Mock 서비스 구현** (내부 테스트용).

**구현 (선택적)**
- [ ] 한국투자증권 KIS Developers API 연동 (모의투자 모드).
  - OAuth 인증 및 토큰 갱신 로직 구현.
  > ⚠️ 외부 API 의존성으로 인해 선택적 구현. Mock으로 대체 가능.

**문서화**
- [ ] **[Diagram]** Reference 도메인 ERD.
- [ ] **[Diagram]** Market Data 수집 플로우.

---

#### Week 11: 버퍼 주차 (또는 실시간 시세 처리) ⚠️ 일정 리스크 대응

> **목적**: 앞 주차에서 밀린 작업 처리 또는 선택적 기능 구현

**옵션 A: 버퍼로 사용**
- [ ] Week 5~10에서 밀린 작업 완료.
- [ ] 기존 코드 리팩토링 및 테스트 보강.
- [ ] 문서화 보완.

**옵션 B: WebSocket 구현 (여유 있을 경우)**
- [ ] Netty / Spring WebFlux를 이용한 WebSocket 서버 구축.
- [ ] 실시간 호가 브로드캐스팅.
- [ ] 평가손익에 실시간 시세 연동.

---

### Phase 4: Resilience & Quality
> "실패는 일상이다"

---

#### Week 12: 분산 시스템 안정성 & 최종 정리 ⭐ 필수 주차

> **Depth Strategy 적용**: Graceful Degradation으로 장애 대응 스토리

**구현**
- [ ] Circuit Breaker, Retry, Rate Limiter 적용 (Resilience4j).
- [ ] **[Resilience]** Kafka 다운 시 Outbox 패턴 검증.
- [ ] **[Resilience]** 장애 복구 배치/재처리 로직 시뮬레이션.
- [ ] **[Depth] Graceful Degradation 구현**:
  - 시세 서버 장애 시: 마지막 캐시된 시세로 주문 접수 → 체결 보류 (PENDING)
  - Fallback Price: 시세 조회 실패 시 마지막 유효 시세 + 경고 플래그
  - 사용자 피드백 메시지 설계: "현재 시세 조회 지연 중, 주문은 정상 접수되었습니다"
- [ ] 동시성/부하 테스트 (k6) & Throughput(TPS), Latency 측정.

**문서화**
- [ ] **[ADR]** Graceful Degradation 전략 (`/docs/adr/011-graceful-degradation.md`)
- [ ] **[Diagram]** 장애 시나리오별 시스템 동작 흐름도.
- [ ] **[Diagram]** 장애 복구 플로우 다이어그램.
- [ ] **[Diagram]** 전체 시스템 Event Flow Diagram (최종 버전).
- [ ] README/ADR/Docs 정리 → **"면접에서 이야기할 스토리"** 위주로 정리.

**회고**
- [ ] Week 12 최종 회고 작성
  - 프로젝트 전체 회고 및 배운 점 정리

---

## 5. 면접 대비 스토리 준비

| 주제 | 질문 예시 | 답변 근거 (주차) |
|:-----|:---------|:---------------|
| **데이터 정합성** | "잔액이 꼬이면 어떻게 하나요?" | Week 2-3 (이중부기, 역분개) |
| **동시성 제어** | "100명이 동시에 주문하면?" | Week 6 (Lock 비교 실험) |
| ⭐ **극한 동시성** | "1000명이 동시에 매수하면 TPS가 얼마나 나오나요?" | Week 6 (극한 테스트, 수치 증명) |
| **장애 처리** | "Kafka가 죽으면?" | Week 4 (Outbox), Week 12 (검증) |
| ⭐ **Graceful Degradation** | "시세 서버가 죽으면 주문은 어떻게 되나요?" | Week 12 (Fallback Price, PENDING 큐) |
| **성능** | "TPS가 얼마나 나오나요?" | Week 12 (k6 부하 테스트) |
| **도메인 이해** | "주문→체결→원장 플로우 설명" | Week 7 (E2E 플로우) |
| ⭐ **슬리피지** | "시장가 주문에서 가격 괴리가 발생하면?" | Week 7 (슬리피지 방어 ADR) |
| **기술 선택** | "왜 이 기술을 선택했나요?" | 각 주차별 ADR 문서 |

---

## 6. 하지 않기로 한 것 (Out of Scope)

### 기존 Out of Scope 유지
- Kubernetes 프로덕션 배포 (Docker Compose로 로컬 개발에 집중)
- 완전한 모니터링 시스템 구축
- 멀티 리전 / DR 구성
- 실거래 (Real Trading)
- 암호화폐 거래소 연동
- 사용자 인증/회원 관리 (기본 JWT만)
- E2E UI 테스트
- 100만 TPS 수준의 부하 테스트

### 추가 Out of Scope (v4 조정)
| 제외 항목 | 이유 |
|-----------|------|
| **지정가(Limit) 주문** | 시장가 즉시 체결로 핵심 플로우 증명 가능 |
| **Order Book 매칭** | 복잡도 대비 면접 어필 효과 낮음 |
| **한투 API 필수 연동** | 외부 의존성 리스크, Mock으로 대체 |
| **WebSocket 필수 구현** | 프론트엔드 영역에 가까움, 백엔드 핵심 아님 |

---

## 7. 기술 스택

| 분류 | 기술 |
|------|------|
| Language | **Java 21** |
| Framework | **Spring Boot 3**, Spring Data JPA |
| DB | **MySQL (InnoDB)** – 원장/주문/포지션 |
| Cache/동시성 | **Redis** |
| 메시징 | **Kafka** |
| Infra | Docker, Docker Compose |
| 관측성 | Spring Actuator |

---

## 8. 성공 기준

### 기술/도메인
- [ ] 주문→체결→원장→포지션 플로우가 **일관된 데이터로 동작**한다.
- [ ] 동시 주문 테스트에서 **잔액/포지션이 꼬이지 않는 것**을 테스트로 증명한다.
- [ ] 최소 1개 이상의 **성능/동시성 이슈를 직접 발견-분석-개선한 사례**가 존재한다.

### 포트폴리오/문서
- [ ] README를 처음 읽는 사람이 "이게 어떤 시스템인지" **5분 안에 이해**할 수 있다.
- [ ] 면접에서 **이 프로젝트만 가지고 30~40분 대화**를 이어갈 수 있는 수준의 스토리가 준비되어 있다.

---

> 이 목표2.md는 v3 대비 **현실적인 범위 조정**과 **핵심 집중**을 통해,  
> 12주 안에 **증권사가 원하는 수준의 엔지니어링 스토리**를 확실히 만들어내는 것을 목표로 한다.
